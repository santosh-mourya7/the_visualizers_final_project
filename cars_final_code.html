<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cars Visualization System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }
        h1, h2 {
            color: #333;
            text-align: center;
        }
        .visualization-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        .vis {
            background-color: white;
            padding: 10px;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            width: 640px; /* Adjusted for wider SVG */
        }
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px;
            border-radius: 3px;
            pointer-events: none;
        }
        button {
            margin: 10px 0;
            padding: 8px 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        #loading, #error {
            color: #333;
            text-align: center;
        }
        #error {
            color: red;
        }
        .legend {
            font-size: 12px;
        }
        .legend-item {
            display: block;
            margin-bottom: 5px;
        }
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            vertical-align: middle;
        }
        .legend-rect {
            width: 10px;
            height: 10px;
            display: inline-block;
            vertical-align: middle;
        }
        .legend-line {
            width: 20px;
            height: 2px;
            display: inline-block;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <h1>Cars Visualization System</h1>
    <div id="loading">Loading data...</div>
    <div id="error" style="display: none;"></div>
    <button id="reset" style="display: none;">Reset</button>
    <div id="visualizations" class="visualization-container" style="display: none;">
        <div>
            <h2>MPG vs. Horsepower Scatter Plot</h2>
            <div id="scatter1" class="vis"></div>
        </div>
        <div>
            <h2>Model Year vs. Cylinders Stacked Bar Chart</h2>
            <div id="barchart" class="vis"></div>
        </div>
        <div>
            <h2>MPG Distribution by Origin Box Plot</h2>
            <div id="boxplot" class="vis"></div>
        </div>
        <div>
            <h2>Average MPG Trend by Origin Line Chart</h2>
            <div id="linechart" class="vis"></div>
        </div>
    </div>

    <script>
        // Load and process Excel file
        function loadExcelFile() {
            const fileName = 'a1-cars.csv';
            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
            document.getElementById('visualizations').style.display = 'none';
            document.getElementById('reset').style.display = 'none';

            fetch(fileName)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('File not found or inaccessible');
                    }
                    return response.arrayBuffer();
                })
                .then(data => {
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheet];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                    // Convert to object array with headers
                    const headers = jsonData[0];
                    const rawData = jsonData.slice(1).map(row => {
                        const obj = {};
                        headers.forEach((header, i) => {
                            obj[header] = row[i];
                        });
                        return obj;
                    });

                    const processedData = processAndCleanData(rawData);
                    if (processedData.length === 0) {
                        throw new Error('No valid data after processing');
                    }

                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('visualizations').style.display = 'flex';
                    document.getElementById('reset').style.display = 'block';
                    createVisualizations(processedData);
                })
                .catch(err => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = 'Error loading file: ' + err.message;
                });
        }

        // Process and clean data
        function processAndCleanData(data) {
            return data.filter(d => {
                return d.MPG && d.Horsepower && d.Horsepower !== 'NA' && d.Weight && d.Acceleration && d['Model Year'] && d.Origin;
            }).map(d => ({
                Car: d.Car || 'Unknown',
                Manufacturer: d.Manufacturer || 'Unknown',
                MPG: +d.MPG,
                Cylinders: +d.Cylinders,
                Displacement: +d.Displacement || 0,
                Horsepower: +d.Horsepower,
                Weight: +d.Weight,
                Acceleration: +d.Acceleration,
                ModelYear: +d['Model Year'],
                Origin: d.Origin
            }));
        }

        // Create visualizations
        function createVisualizations(data) {
            const width = 600; // Increased to accommodate legend
            const height = 400;
            const margin = { top: 20, right: 120, bottom: 50, left: 50 }; // Increased right margin
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            // Color scale for Origin
            const color = d3.scaleOrdinal()
                .domain(['American', 'European', 'Japanese'])
                .range(['red', 'blue', 'green']);

            // Tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            // Scatter Plot 1: MPG vs. Horsepower
            const scatter1Svg = d3.select('#scatter1')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const scatter1 = scatter1Svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x1 = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.MPG) * 1.1])
                .range([0, plotWidth]);

            const y1 = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.Horsepower) * 1.1])
                .range([plotHeight, 0]);

            const x1Axis = scatter1.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0,${plotHeight})`)
                .call(d3.axisBottom(x1))
                .append('text')
                .attr('x', plotWidth / 2)
                .attr('y', 40)
                .attr('fill', 'black')
                .text('MPG');

            const y1Axis = scatter1.append('g')
                .attr('class', 'y-axis')
                .call(d3.axisLeft(y1))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -plotHeight / 2)
                .attr('y', -40)
                .attr('fill', 'black')
                .text('Horsepower');

            // Legend for Scatter Plot
            const scatterLegend = scatter1Svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${width - margin.right + 10}, ${margin.top})`);

            color.domain().forEach((origin, i) => {
                const legendItem = scatterLegend.append('g')
                    .attr('class', 'legend-item')
                    .attr('transform', `translate(0, ${i * 20})`);
                legendItem.append('circle')
                    .attr('class', 'legend-dot')
                    .attr('cx', 5)
                    .attr('cy', 5)
                    .attr('r', 5)
                    .attr('fill', color(origin));
                legendItem.append('text')
                    .attr('x', 15)
                    .attr('y', 9)
                    .text(origin);
            });

            // Stacked Bar Chart
            const barSvg = d3.select('#barchart')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const bar = barSvg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const years = [...new Set(data.map(d => d.ModelYear))].sort();
            const cylinders = [...new Set(data.map(d => d.Cylinders))].sort();
            const colorBar = d3.scaleOrdinal()
                .domain(cylinders)
                .range(d3.schemeCategory10);

            const xBar = d3.scaleBand()
                .domain(years)
                .range([0, plotWidth])
                .padding(0.1);

            const yBar = d3.scaleLinear()
                .range([plotHeight, 0]);

            const xBarAxis = bar.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0,${plotHeight})`)
                .call(d3.axisBottom(xBar))
                .append('text')
                .attr('x', plotWidth / 2)
                .attr('y', 40)
                .attr('fill', 'black')
                .text('Model Year');

            const yBarAxis = bar.append('g')
                .attr('class', 'y-axis')
                .call(d3.axisLeft(yBar))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -plotHeight / 2)
                .attr('y', -40)
                .attr('fill', 'black')
                .text('Count');

            // Legend for Bar Chart
            const barLegend = barSvg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${width - margin.right + 10}, ${margin.top})`);

            cylinders.forEach((cyl, i) => {
                const legendItem = barLegend.append('g')
                    .attr('class', 'legend-item')
                    .attr('transform', `translate(0, ${i * 20})`);
                legendItem.append('rect')
                    .attr('class', 'legend-rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', 10)
                    .attr('height', 10)
                    .attr('fill', colorBar(cyl));
                legendItem.append('text')
                    .attr('x', 15)
                    .attr('y', 9)
                    .text(`${cyl} Cylinders`);
            });

            // Box Plot: MPG by Origin
            const boxSvg = d3.select('#boxplot')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const box = boxSvg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const origins = ['American', 'European', 'Japanese'];
            const xBox = d3.scaleBand()
                .domain(origins)
                .range([0, plotWidth])
                .padding(0.4);

            const yBox = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.MPG) * 1.1])
                .range([plotHeight, 0]);

            const xBoxAxis = box.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0,${plotHeight})`)
                .call(d3.axisBottom(xBox))
                .append('text')
                .attr('x', plotWidth / 2)
                .attr('y', 40)
                .attr('fill', 'black')
                .text('Origin');

            const yBoxAxis = box.append('g')
                .attr('class', 'y-axis')
                .call(d3.axisLeft(yBox))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -plotHeight / 2)
                .attr('y', -40)
                .attr('fill', 'black')
                .text('MPG');

            // Legend for Box Plot
            const boxLegend = boxSvg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${width - margin.right + 10}, ${margin.top})`);

            origins.forEach((origin, i) => {
                const legendItem = boxLegend.append('g')
                    .attr('class', 'legend-item')
                    .attr('transform', `translate(0, ${i * 20})`);
                legendItem.append('rect')
                    .attr('class', 'legend-rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', 10)
                    .attr('height', 10)
                    .attr('fill', color(origin));
                legendItem.append('text')
                    .attr('x', 15)
                    .attr('y', 9)
                    .text(origin);
            });

            // Line Chart: Average MPG by Model Year and Origin
            const lineSvg = d3.select('#linechart')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const line = lineSvg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const xLine = d3.scaleLinear()
                .domain(d3.extent(years))
                .range([0, plotWidth]);

            const yLine = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.MPG) * 1.1])
                .range([plotHeight, 0]);

            const xLineAxis = line.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0,${plotHeight})`)
                .call(d3.axisBottom(xLine).tickFormat(d3.format('d')))
                .append('text')
                .attr('x', plotWidth / 2)
                .attr('y', 40)
                .attr('fill', 'black')
                .text('Model Year');

            const yLineAxis = line.append('g')
                .attr('class', 'y-axis')
                .call(d3.axisLeft(yLine))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -plotHeight / 2)
                .attr('y', -40)
                .attr('fill', 'black')
                .text('Average MPG');

            // Legend for Line Chart
            const lineLegend = lineSvg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${width - margin.right + 10}, ${margin.top})`);

            origins.forEach((origin, i) => {
                const legendItem = lineLegend.append('g')
                    .attr('class', 'legend-item')
                    .attr('transform', `translate(0, ${i * 20})`);
                legendItem.append('line')
                    .attr('class', 'legend-line')
                    .attr('x1', 0)
                    .attr('x2', 20)
                    .attr('y1', 5)
                    .attr('y2', 5)
                    .attr('stroke', color(origin))
                    .attr('stroke-width', 2);
                legendItem.append('text')
                    .attr('x', 25)
                    .attr('y', 9)
                    .text(origin);
            });

            // Data for stacked bar
            function getBarData(selectedData) {
                const stackedData = years.map(year => {
                    const yearData = selectedData.filter(d => d.ModelYear === year);
                    const counts = cylinders.reduce((acc, cyl) => {
                        acc[cyl] = yearData.filter(d => d.Cylinders === cyl).length;
                        return acc;
                    }, {});
                    return { year, ...counts };
                });
                return d3.stack().keys(cylinders)(stackedData);
            }

            // Data for box plot
            function getBoxData(selectedData) {
                return origins.map(origin => {
                    const values = selectedData.filter(d => d.Origin === origin).map(d => d.MPG).sort(d3.ascending);
                    const q1 = d3.quantile(values, 0.25);
                    const median = d3.quantile(values, 0.5);
                    const q3 = d3.quantile(values, 0.75);
                    const iqr = q3 - q1;
                    const min = Math.max(d3.min(values) || 0, q1 - 1.5 * iqr);
                    const max = Math.min(d3.max(values) || d3.max(data, d => d.MPG), q3 + 1.5 * iqr);
                    const outliers = values.filter(v => v < min || v > max);
                    return { origin, q1, median, q3, min, max, outliers };
                });
            }

            // Data for line chart
            function getLineData(selectedData) {
                const lineData = origins.map(origin => {
                    const yearlyData = years.map(year => {
                        const yearOriginData = selectedData.filter(d => d.Origin === origin && d.ModelYear === year);
                        const avgMPG = yearOriginData.length > 0 ? d3.mean(yearOriginData, d => d.MPG) : null;
                        return { year, avgMPG, origin };
                    });
                    return { origin, values: yearlyData.filter(d => d.avgMPG !== null) };
                });
                return lineData;
            }

            // Zooming
            let transform1 = d3.zoomIdentity;
            let transform2 = d3.zoomIdentity;
            let transform3 = d3.zoomIdentity;
            let transform4 = d3.zoomIdentity;

            const zoom1 = d3.zoom()
                .scaleExtent([1, 10])
                .on('zoom', zoomed1);

            const zoom2 = d3.zoom()
                .scaleExtent([1, 10])
                .on('zoom', zoomed2);

            const zoom3 = d3.zoom()
                .scaleExtent([1, 10])
                .on('zoom', zoomed3);

            const zoom4 = d3.zoom()
                .scaleExtent([1, 10])
                .on('zoom', zoomed4);

            scatter1Svg.call(zoom1);
            barSvg.call(zoom2);
            boxSvg.call(zoom3);
            lineSvg.call(zoom4);

            // Brushing
            const brush1 = d3.brush()
                .extent([[0, 0], [plotWidth, plotHeight]])
                .on('brush end', brushed);

            scatter1.append('g')
                .attr('class', 'brush')
                .call(brush1);

            // Reset button
            d3.select('#reset').on('click', () => {
                selectedData = data;
                scatter1.select('.brush').call(brush1.move, null);
                transform1 = d3.zoomIdentity;
                transform2 = d3.zoomIdentity;
                transform3 = d3.zoomIdentity;
                transform4 = d3.zoomIdentity;
                scatter1Svg.call(zoom1.transform, transform1);
                barSvg.call(zoom2.transform, transform2);
                boxSvg.call(zoom3.transform, transform3);
                lineSvg.call(zoom4.transform, transform4);
                updateVisualizations(selectedData, transform1, transform2, transform3, transform4);
            });

            // Draw initial visualizations
            let selectedData = data;
            updateVisualizations(selectedData, transform1, transform2, transform3, transform4);

            function updateVisualizations(data, transform1, transform2, transform3, transform4) {
                // Scatter Plot
                const newX1 = transform1.rescaleX(x1);
                const newY1 = transform1.rescaleY(y1);

                scatter1.selectAll('.dot')
                    .data(data)
                    .join('circle')
                    .attr('class', 'dot')
                    .attr('cx', d => transform1.applyX(x1(d.MPG)))
                    .attr('cy', d => transform1.applyY(y1(d.Horsepower)))
                    .attr('r', 5)
                    .attr('fill', d => color(d.Origin))
                    .attr('opacity', 0.7)
                    .on('mouseover', (event, d) => {
                        tooltip.transition().duration(200).style('opacity', 0.9);
                        tooltip.html(`Car: ${d.Car}<br>MPG: ${d.MPG}<br>Horsepower: ${d.Horsepower}<br>Origin: ${d.Origin}`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', () => tooltip.transition().duration(500).style('opacity', 0));

                scatter1.select('.x-axis').call(d3.axisBottom(newX1));
                scatter1.select('.y-axis').call(d3.axisLeft(newY1));

                // Stacked Bar Chart
                const stackedData = getBarData(data);
                yBar.domain([0, d3.max(stackedData[stackedData.length - 1], d => d[1])]);

                const xBarZoomed = d3.scaleLinear()
                    .domain([0, years.length])
                    .range(transform2.rescaleX(d3.scaleLinear().domain([0, years.length]).range([0, plotWidth])).range());

                bar.selectAll('g.layer')
                    .data(stackedData)
                    .join('g')
                    .attr('class', 'layer')
                    .attr('fill', d => colorBar(d.key))
                    .selectAll('rect')
                    .data(d => d)
                    .join('rect')
                    .attr('x', d => {
                        const index = years.indexOf(d.data.year);
                        return xBarZoomed(index);
                    })
                    .attr('y', d => transform2.applyY(yBar(d[1])))
                    .attr('height', d => transform2.applyY(yBar(d[0])) - transform2.applyY(yBar(d[1])))
                    .attr('width', xBar.bandwidth() * transform2.k)
                    .on('mouseover', (event, d) => {
                        tooltip.transition().duration(200).style('opacity', 0.9);
                        const cyl = event.target.parentNode.__data__.key;
                        tooltip.html(`Year: ${d.data.year}<br>Cylinders: ${cyl}<br>Count: ${d[1] - d[0]}`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', () => tooltip.transition().duration(500).style('opacity', 0));

                bar.select('.x-axis').call(d3.axisBottom(xBarZoomed).tickValues(years.map((_, i) => i)).tickFormat(i => years[i]));
                bar.select('.y-axis').call(d3.axisLeft(transform2.rescaleY(yBar)));

                // Box Plot
                const boxData = getBoxData(data);
                const xBoxZoomed = d3.scaleLinear()
                    .domain([0, origins.length])
                    .range(transform3.rescaleX(d3.scaleLinear().domain([0, origins.length]).range([0, plotWidth])).range());

                const boxGroups = box.selectAll('.box-group')
                    .data(boxData)
                    .join('g')
                    .attr('class', 'box-group')
                    .attr('transform', d => {
                        const index = origins.indexOf(d.origin);
                        return `translate(${xBoxZoomed(index)},0)`;
                    });

                const boxWidth = xBox.bandwidth() * transform3.k;

                // Vertical line for min to max
                boxGroups.selectAll('.range-line')
                    .data(d => [d])
                    .join('line')
                    .attr('class', 'range-line')
                    .attr('x1', boxWidth / 2)
                    .attr('x2', boxWidth / 2)
                    .attr('y1', d => transform3.applyY(yBox(d.min)))
                    .attr('y2', d => transform3.applyY(yBox(d.max)))
                    .attr('stroke', 'black');

                // Box for Q1 to Q3
                boxGroups.selectAll('.box')
                    .data(d => [d])
                    .join('rect')
                    .attr('class', 'box')
                    .attr('x', 0)
                    .attr('y', d => transform3.applyY(yBox(d.q3)))
                    .attr('width', boxWidth)
                    .attr('height', d => transform3.applyY(yBox(d.q1)) - transform3.applyY(yBox(d.q3)))
                    .attr('fill', d => color(d.origin))
                    .attr('opacity', 0.7)
                    .on('mouseover', (event, d) => {
                        tooltip.transition().duration(200).style('opacity', 0.9);
                        tooltip.html(`Origin: ${d.origin}<br>Median MPG: ${d.median.toFixed(1)}<br>Q1: ${d.q1.toFixed(1)}<br>Q3: ${d.q3.toFixed(1)}<br>Min: ${d.min.toFixed(1)}<br>Max: ${d.max.toFixed(1)}`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', () => tooltip.transition().duration(500).style('opacity', 0));

                // Median line
                boxGroups.selectAll('.median-line')
                    .data(d => [d])
                    .join('line')
                    .attr('class', 'median-line')
                    .attr('x1', 0)
                    .attr('x2', boxWidth)
                    .attr('y1', d => transform3.applyY(yBox(d.median)))
                    .attr('y2', d => transform3.applyY(yBox(d.median)))
                    .attr('stroke', 'black')
                    .attr('stroke-width', 2);

                // Whiskers
                boxGroups.selectAll('.whisker-min')
                    .data(d => [d])
                    .join('line')
                    .attr('class', 'whisker-min')
                    .attr('x1', boxWidth / 4)
                    .attr('x2', boxWidth * 3 / 4)
                    .attr('y1', d => transform3.applyY(yBox(d.min)))
                    .attr('y2', d => transform3.applyY(yBox(d.min)))
                    .attr('stroke', 'black');

                boxGroups.selectAll('.whisker-max')
                    .data(d => [d])
                    .join('line')
                    .attr('class', 'whisker-max')
                    .attr('x1', boxWidth / 4)
                    .attr('x2', boxWidth * 3 / 4)
                    .attr('y1', d => transform3.applyY(yBox(d.max)))
                    .attr('y2', d => transform3.applyY(yBox(d.max)))
                    .attr('stroke', 'black');

                // Outliers
                boxGroups.selectAll('.outlier')
                    .data(d => d.outliers.map(val => ({ origin: d.origin, value: val })))
                    .join('circle')
                    .attr('class', 'outlier')
                    .attr('cx', boxWidth / 2)
                    .attr('cy', d => transform3.applyY(yBox(d.value)))
                    .attr('r', 3)
                    .attr('fill', d => color(d.origin))
                    .on('mouseover', (event, d) => {
                        tooltip.transition().duration(200).style('opacity', 0.9);
                        tooltip.html(`Origin: ${d.origin}<br>MPG: ${d.value.toFixed(1)}`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', () => tooltip.transition().duration(500).style('opacity', 0));

                box.select('.x-axis').call(d3.axisBottom(xBoxZoomed).tickValues(origins.map((_, i) => i)).tickFormat(i => origins[i]));
                box.select('.y-axis').call(d3.axisLeft(transform3.rescaleY(yBox)));

                // Line Chart
                const lineData = getLineData(data);
                const lineGenerator = d3.line()
                    .x(d => transform4.applyX(xLine(d.year)))
                    .y(d => transform4.applyY(yLine(d.avgMPG)))
                    .defined(d => d.avgMPG !== null);

                line.selectAll('.line')
                    .data(lineData)
                    .join('path')
                    .attr('class', 'line')
                    .attr('d', d => lineGenerator(d.values))
                    .attr('fill', 'none')
                    .attr('stroke', d => color(d.origin))
                    .attr('stroke-width', 2);

                // Add points for tooltips
                line.selectAll('.line-points')
                    .data(lineData)
                    .join('g')
                    .attr('class', 'line-points')
                    .selectAll('circle')
                    .data(d => d.values)
                    .join('circle')
                    .attr('cx', d => transform4.applyX(xLine(d.year)))
                    .attr('cy', d => transform4.applyY(yLine(d.avgMPG)))
                    .attr('r', 4)
                    .attr('fill', d => color(d.origin))
                    .on('mouseover', (event, d) => {
                        tooltip.transition().duration(200).style('opacity', 0.9);
                        tooltip.html(`Origin: ${d.origin}<br>Year: ${d.year}<br>Avg MPG: ${d.avgMPG.toFixed(1)}`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', () => tooltip.transition().duration(500).style('opacity', 0));

                line.select('.x-axis').call(d3.axisBottom(transform4.rescaleX(xLine)).tickFormat(d3.format('d')));
                line.select('.y-axis').call(d3.axisLeft(transform4.rescaleY(yLine)));
            }

            function zoomed1(event) {
                transform1 = event.transform;
                updateVisualizations(selectedData, transform1, transform2, transform3, transform4);
            }

            function zoomed2(event) {
                transform2 = event.transform;
                updateVisualizations(selectedData, transform1, transform2, transform3, transform4);
            }

            function zoomed3(event) {
                transform3 = event.transform;
                updateVisualizations(selectedData, transform1, transform2, transform3, transform4);
            }

            function zoomed4(event) {
                transform4 = event.transform;
                updateVisualizations(selectedData, transform1, transform2, transform3, transform4);
            }

            function brushed(event, source) {
                if (!event.selection) {
                    selectedData = data;
                } else {
                    const [[x0, y0], [x1, y1]] = event.selection;
                    selectedData = data.filter(d => {
                        const x = transform1.applyX(x1(d.MPG));
                        const y = transform1.applyY(y1(d.Horsepower));
                        return x >= x0 && x <= x1 && y >= y0 && y <= y1;
                    });
                }
                transform1 = d3.zoomIdentity; // Reset scatter plot zoom on brush
                scatter1Svg.call(zoom1.transform, transform1);
                updateVisualizations(selectedData, transform1, transform2, transform3, transform4);
            }
        }

        // Start loading the file
        loadExcelFile();
    </script>
</body>
</html>